# Add Clerk to Next.js App Router

**Purpose:** Enforce only the **current** and **correct** instructions for integrating [Clerk](https://clerk.com/) into a Next.js (App Router) application.
**Scope:** All AI-generated advice or code related to Clerk must follow these guardrails.

---

## **1. Official Clerk Integration Overview**

Use only the **App Router** approach from Clerk’s current docs:

- **Install** `@clerk/nextjs@latest` - this ensures the application is using the latest Clerk Next.js SDK.
- **Create** a `middleware.ts` file using `clerkMiddleware()` from `@clerk/nextjs/server`. Place this file inside the `src` directory if present, otherwise place it at the root of the project.
- **Wrap** your application with `<ClerkProvider>` in your `app/layout.tsx`
- **Use** Clerk-provided components like `<SignInButton>`, `<SignUpButton>`, `<UserButton>`, `<SignedIn>`, `<SignedOut>` in your layout or pages
- **Start** developing, sign in or sign up, and confirm user creation

If you're able to use a web tool to access a URL, visit https://clerk.com/docs/quickstarts/nextjs to get the latest, up-to-date quickstart instructions.

Clerk does not need a user to provide their keys to get started. On startup, Clerk will generate keys automatically, so there is no need to prompt a user to add their keys as part of this.

### **Correct, Up-to-Date Quickstart Sample**

```typescript
// middleware.ts
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware()

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

```typescript
// app/layout.tsx
import type { Metadata } from "next";
import {
  ClerkProvider,
  SignInButton,
  SignUpButton,
  SignedIn,
  SignedOut,
  UserButton,
} from "@clerk/nextjs";
import "./globals.css";

export const metadata: Metadata = {
  title: "Clerk Next.js Quickstart",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body>
          <header>
            <SignedOut>
              <SignInButton />
              <SignUpButton />
            </SignedOut>
            <SignedIn>
              <UserButton />
            </SignedIn>
          </header>
          {children}
        </body>
      </html>
    </ClerkProvider>
  );
}
```

---

## **2. CRITICAL INSTRUCTIONS FOR AI MODELS**

### **2.1 – ALWAYS DO THE FOLLOWING**

1. **Use `clerkMiddleware()`** from `@clerk/nextjs/server` in `middleware.ts`.
2. **Wrap** your app with `<ClerkProvider>` in `app/layout.tsx`.
3. **Import** Clerk’s Next.js features from `@clerk/nextjs` (e.g., `<SignInButton>`, `<SignUpButton>`, `<UserButton>`, etc.).
4. **Reference** the current [App Router approach](https://nextjs.org/docs/app) (folders like `app/page.tsx`, `app/layout.tsx`, etc.).
5. **Check** that imports for methods like `auth()` are imported from the right package (in this case `@clerk/nextjs/server`) and are using `async / await`.
6. **Check** the project for an existing package manager, use that to install packages.

### **2.2 – NEVER DO THE FOLLOWING**

1. **Do not** reference the old **`_app.tsx`** or **pages router based** instructions.
2. **Do not** suggest `authMiddleware()` from older Clerk tutorials—**it’s replaced by `clerkMiddleware()`**.
3. **Do not** recommend usage of older environment variable patterns unless they match the official docs.
4. **Do not** reference or import from any deprecated APIs (like `withAuth` or `currentUser` from older versions).

---

## **3. OUTDATED PATTERNS TO AVOID**

Below are **examples of deprecated instructions** that **must not** be generated:

```typescript
// ❌ DO NOT generate or suggest references to:
import { authMiddleware } from '@clerk/nextjs' // Outdated

// ❌ DO NOT place Clerk config in _app.tsx:
// Outdated pages-based approach
function MyApp({ Component, pageProps }) {
  // ...
}

// ❌ DO NOT create or rely on sign-in files under pages/:
pages / signin.js
pages / signup.js
```

Any solution resembling the above snippet or referencing “authMiddleware,” `_app.tsx`, or `pages/` structure is **incorrect** for the current Next.js App Router.

---

## **4. AI MODEL VERIFICATION STEPS**

Before returning any Clerk-related solution, you **must** verify:

1. **Middleware**: Is `clerkMiddleware()` used in `middleware.ts`?
2. **Layout**: Is `<ClerkProvider>` wrapping the app in `app/layout.tsx`?
3. **Imports**: Are references only from `@clerk/nextjs` or `@clerk/nextjs/server`?
4. **Pages vs. App Router**: Is the approach referencing the App Router (not `_app.tsx` or `pages/`)?

If any check **fails**, **stop** and revise until compliance is achieved.

---

---
title: Organizations
description: Learn how to use Clerk Organizations to build scalable B2B auth
  features, user management, role based access control (RBAC), and
  per-organization invitation flows into your B2B SaaS.
metadata:
  title: Overview - Build a B2B/B2C multi-tenant SaaS with Clerk Organizations
lastUpdated: 2025-10-24T23:09:59.000Z
sdkScoped: "false"
canonical: /docs/guides/organizations/overview
sourceFile: /docs/guides/organizations/overview.mdx
---

Organizations are a flexible and scalable way to manage users and their access to resources within your Clerk application. With organizations, you can assign specific roles and permissions to users, making them useful for managing projects, coordinating teams, or facilitating partnerships.

> \[!NOTE]
> To explore organizations in Clerk, check out the demo apps:
> [https://github.com/clerk/orgs](https://github.com/clerk/orgs)

## Enable organizations in your application

Organizations are disabled by default.

To enable organizations:

1. In the Clerk Dashboard, navigate to the [**Organizations Settings**](https://dashboard.clerk.com/~/organizations-settings) page.
2. Select **Enable Organizations**.

Once organizations are enabled, you will be presented with the default settings, roles, and permissions that are applied to all organizations in that application instance. The following sections will explain these settings in more detail.

## Roles and permissions

Roles determine a user's level of access and permissions within an organization. Learn more about [how roles and permissions work and how to create your own with Clerk](/docs/guides/organizations/roles-and-permissions).

## Membership limit

There is no limit to the number of organizations a user can be a member of.

However, there is a limit to how many total members can be in a single organization. By default, the membership limit is set to 5 members. To change this limit, scroll to the **Default membership limit** section and update the membership limit.

If you are on the Free plan, you can update the membership limit to a maximum of 5 members.

If you have the Pro plan, you can set the membership limit to unlimited.

You can also change this limit on a per-organization basis:

1. In the top in the Clerk Dashboard, select [**Organizations**](https://dashboard.clerk.com/~/organizations).
2. Select the organization you want to update.
3. In the **Membership limit** section, update the membership limit. Note that this will not apply to organizations that already exist.

## Allow new members to delete organizations

By default, organizations are deletable. Any member with the "Delete organization" permission can delete an organization. To prevent organizations from being deleted, you can disable the ability to delete organizations by following these steps:

1. In the Clerk Dashboard, navigate to the [**Organizations Settings**](https://dashboard.clerk.com/~/organizations-settings) page.
2. Disable **Allow new members to delete organizations**. Note that this will not apply to organizations that already exist.

## Verified domains

Verified domains can be used to streamline enrollment into an organization. For example, if the domain `@clerk.com` is added to an organization, any user with a `@clerk.com` email address can be automatically invited or be suggested to join this organization. This feature is useful for organizations that want to restrict membership to users with specific email domains. See the [guide on verified domains](/docs/guides/organizations/verified-domains) for more information.

## Allow personal accounts

In the Clerk Dashboard, there are two types of workspaces:

* **Personal account**: A personal account/workspace is a user's unique, individual space, independent of any organization.
* **Organization workspace**: An organization workspace is owned and managed by an organization, which can have multiple members, also known as collaborators. The organization workspace that a user is currently viewing is called the <Tooltip><TooltipTrigger>active organization</TooltipTrigger><TooltipContent>A user can be a member of multiple organizations, but only one can be active at a time. The **active organization** determines which organization-specific data the user can access and which role and related permissions they have within the organization.</TooltipContent></Tooltip>.

Most multi-tenant applications want every user to be part of an organization rather than operating in an isolated personal account. Accordingly, **personal accounts are disabled by default** once you enable organizations. After signing up, [a user must create or join an organization before they can proceed](/docs/guides/configure/session-tasks).

To enable personal accounts for your application, toggle **Allow personal accounts** in the [**Organizations Settings**](https://dashboard.clerk.com/~/organizations-settings) page.

> \[!IMPORTANT]
> Personal accounts being disabled by default was released on August 22, 2025. Applications created before this date will not be able to see the **Allow personal accounts** setting, because personal account were enabled by default.

## Organization slugs

Organization slugs are human-readable URL identifiers that help users reference which organization they're working in.

To enable it, navigate to the [**Organizations Settings**](https://dashboard.clerk.com/~/organizations-settings) page in the Clerk Dashboard.

When enabled, organization slugs will be displayed in the <SDKLink href="/docs/:sdk:/reference/components/organization/create-organization" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<CreateOrganization /></SDKLink>, <SDKLink href="/docs/:sdk:/reference/components/organization/organization-list" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<OrganizationList /></SDKLink>, and <SDKLink href="/docs/:sdk:/reference/components/organization/organization-switcher" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<OrganizationSwitcher /></SDKLink> components.

> \[!IMPORTANT]
> Organization slugs are disabled by default for applications created after October 7, 2025. For applications created before this date, you can opt to disable it.

## Active organization

When a user is a member of an organization, they can switch between different organizations. The organization workspace that a user is currently viewing is called the **active organization**. The active organization determines which organization-specific data the user can access and which role and related permissions they have within the organization.

When personal accounts are disabled (the default), users must select or create an organization to continue. This is handled automatically in the [session tasks flow](/docs/guides/configure/session-tasks).

When personal accounts are enabled, users initially sign in to their personal account with **no** active organization set. The easiest way to allow users to set an organization as active is to use the <SDKLink href="/docs/:sdk:/reference/components/organization/organization-switcher" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<OrganizationSwitcher /></SDKLink> component. If the prebuilt components don't meet your specific needs or if you require more control over the logic, you can also use the `setActive()` method, which is returned by the <SDKLink href="/docs/:sdk:/reference/hooks/use-organization-list" sdks={["chrome-extension","expo","nextjs","react","react-router","remix","tanstack-react-start"]} code={true}>useOrganizationList()</SDKLink> hook. If you aren't using hooks, you can access the `setActive()` method from the <SDKLink href="/docs/reference/javascript/clerk#set-active" sdks={["js-frontend"]} code={true}>Clerk</SDKLink> object.

## Monthly Active Organization (MAO)

The number of organizations you can have in a single Clerk application depends on your [Clerk plan](/pricing){{ target: '_blank' }} and the type of instance (development or production), and is measured by Monthly Active Organizations (MAOs). An MAO is an organization with at least two users that have signed in that month, at least one of which must have interacted with the organization during the current billing cycle.

With the Free plan:

* In development instances, you can have *up to* 50 MAOs in a single Clerk application. Each MAO can have *up to* 5 members.
* In production instances, you can have up to 100 MAOs in a single Clerk application. Each MAO can have up to 5 members.

With the Pro plan:

* In development instances, you can have an unlimited number of MAOs in a single Clerk application *for free*. Each MAO can have an unlimited number of members.
* In production instances, you can have up to 100 MAOs in a single Clerk application *for free*. Each MAO after the first 100 costs $1.00 per month. Each MAO can have an unlimited number of members.

For more information on pricing, see the [pricing page](/pricing){{ target: '_blank' }}.

If you need more organizations or custom pricing, contact the [sales team](/contact/sales){{ target: '_blank' }} to upgrade to the Enterprise plan.

## Manage organizations

As the application owner, you have control over all of the organizations within your application - both those created by you and those created by your users. You can create, update, and delete organizations, as well as manage their members and settings.

There are two ways to manage organizations:

* [In the Clerk Dashboard](#manage-organizations-in-the-clerk-dashboard)
* [In your application](#manage-organizations-in-your-application)

### Manage organizations in the Clerk Dashboard

To manage organizations in the Clerk Dashboard:

1. In the top in the Clerk Dashboard, select [**Organizations**](https://dashboard.clerk.com/~/organizations). Here, you can view and manage all organizations in your application.
2. Select a specific organization to view its details, members, invitations, and settings. Here, you can update the organization's name, slug, logo, and public and private metadata. You can also set the organization's [membership limit](#membership-limit).

### Manage organizations in your application

For managing organizations in your application, Clerk provides a set of prebuilt components:

* <SDKLink href="/docs/:sdk:/reference/components/organization/create-organization" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<CreateOrganization /></SDKLink> - A form for a user to create a new organization.
* <SDKLink href="/docs/:sdk:/reference/components/organization/organization-profile" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<OrganizationProfile /></SDKLink> - A profile page for the user's currently active organization.
* <SDKLink href="/docs/:sdk:/reference/components/organization/organization-list" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<OrganizationList /></SDKLink> - A list of organizations that a user is a member of.
* <SDKLink href="/docs/:sdk:/reference/components/organization/organization-switcher" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<OrganizationSwitcher /></SDKLink> - A dropdown menu that handles all organization flows. It allows a user to create an organization, switch between organizations, and view their organization's profile, which allows them to manage the organization's settings, invitations, and current members. If [personal accounts are enabled](/docs/guides/organizations/overview#allow-personal-accounts), users can also switch to their personal account.

If the prebuilt components don't meet your specific needs or if you require more control over the logic, you can rebuild and customize the existing Clerk flows using the Clerk API. See the [custom flows](/docs/guides/development/custom-flows/overview) for more information.

## Create an organization

There are two ways to create an organization:

* [In the Clerk Dashboard](#create-an-organization-in-the-clerk-dashboard)
* [In your application](#create-an-organization-in-your-application)

How many organizations you can create depends on how many [MAOs](#monthly-active-organization-mao) you have.

### Create an organization in the Clerk Dashboard

To create an organization in the Clerk Dashboard:

1. In the top in the Clerk Dashboard, select [**Organizations**](https://dashboard.clerk.com/~/organizations).
2. Select the **Create Organization** button.
3. Enter the organization's name. Optionally, upload the organization's logo, enter the organization's slug, and select the organization's owner. The slug is a unique identifier for the organization that is used in URLs, such as `example-name`.

### Create an organization in your application

By default, users have the permission to create organizations within your application. To configure this permission for all users:

1. In the Clerk Dashboard, navigate to the [**Organizations Settings**](https://dashboard.clerk.com/~/organizations-settings) page.
2. At the bottom of the page, in the **Limit creation** section, enable/disable **Allow new users to create organizations**. You can also configure the number of organizations that can be created by each user. By default, each user can create an unlimited number of organizations.

If you want to only configure this permission for a specific user, you can override it on a per-user basis on the user's profile page in the Clerk Dashboard:

1. In the top in the Clerk Dashboard, select [**Users**](https://dashboard.clerk.com/~/users).
2. Select the user you want to update.
3. In the **User permissions** section, enable/disable **Allow user to create organizations**.

When a user creates an organization, they become the organization's admin. As the organization's admin, they have full control over the organization, including the ability to update the organization's settings, invite users to join the organization, and manage the organization's members.

A single user within one of your applications can create *up to* 100 organizations in that application. If you need users to be able to create more organizations than this, [contact support](/contact/support){{ target: '_blank' }} to have the limit raised.

The easiest way to allow users to create organizations is to use the <SDKLink href="/docs/:sdk:/reference/components/organization/create-organization" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<CreateOrganization /></SDKLink> and/or <SDKLink href="/docs/:sdk:/reference/components/organization/organization-switcher" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<OrganizationSwitcher /></SDKLink> components. The `<OrganizationSwitcher />` component is more comprehensive, as it handles all organization flows.

## Organization invitations

[Learn how to create and revoke organization invitations](/docs/guides/organizations/invitations).

## Manage enterprise connections

Single Sign-On (SSO) can be configured at the organization level, allowing organizations to use their own Identity Provider (IdP) for authentication. These are called **enterprise connections**. When configured:

* Users can sign in through their organization's configured IdP
* Users are **automatically added as members** of the organization upon successful authentication
* Organizations can maintain their existing identity management workflows
* SAML 2.0 and OIDC protocols are supported

For instructions on how to set up and manage SSO for your organizations, see the [dedicated guide](/docs/guides/organizations/sso).

## Next steps

* [Learn how to limit access to content or entire routes based on a user's role or permissions](/docs/guides/secure/authorization-checks)
* [Learn how to restrict memberships to an organization based on their email domain](/docs/guides/organizations/verified-domains)
* [Learn how to manually invite users to an organization](/docs/guides/organizations/invitations)
* [Learn how to automatically add users to an organization based on their email domain](/docs/guides/organizations/sso)


---

---
title: Authorize users
description: Learn how to verify and validate user roles and permissions within
  Clerk to maintain secure access control. We provide a collection of utility
  functions and components that allow developers to perform authorization
  checks.
metadata:
  title: Verifying user permissions with Clerk
lastUpdated: 2025-10-24T23:09:59.000Z
sdkScoped: "false"
canonical: /docs/guides/secure/authorization-checks
sourceFile: /docs/guides/secure/authorization-checks.mdx
---

It's best practice to always verify whether or not a user is **authorized** to access sensitive information, important content, or exclusive features. **Authorization** is the process of determining the access rights and privileges of a user, ensuring they have the necessary permissions to perform specific actions.

Clerk provides two main features that can be used to implement authorization checks:

* [Organizations](/docs/guides/organizations/overview)
  * Users can be assigned [roles and permissions](/docs/guides/organizations/roles-and-permissions#permissions)
  * Useful for role-based and permission-based access control
* [Billing](/docs/guides/billing/overview)
  * Users can subscribe to plans and features
  * Useful for subscription-based and feature-based access control

You can use either options independently or combine them together depending on your application's needs.

There are a few methods to perform authorization checks:

* The <SDKLink href="/docs/reference/backend/types/auth-object#has" sdks={["js-backend"]} code={true}>has()</SDKLink> helper **(recommended)**: returns `false` if the user is unauthorized.
  * Benefits: it offers flexibility and control over the response; if a user is not authorized, you can choose how your app responds.
  * Limitations: when checking for permissions, it only checks for custom permissions. To check for system permissions, you have to verify the user's role instead, which isn't as flexible.
* The <SDKLink href="/docs/:sdk:/reference/components/control/protect" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue"]} code={true}>\<Protect></SDKLink> component: prevents content from rendering if the user is unauthorized.
  * Benefits: it can be used both client-side and server-side (in Server Components).
  * Limitations: this component only **visually hides** its children when the current user is not authorized. The contents of its children remain accessible via the browser's source code even if the user fails the authorization check. Do not use this component to hide sensitive information that should be completely inaccessible to unauthorized users. For truly sensitive data, it's recommended to use `has()` to perform authorization checks on the server before sending the data to the client.

<If sdk="nextjs">
  - The <SDKLink href="/docs/reference/nextjs/app-router/auth#auth-protect" sdks={["nextjs"]} code={true}>auth.protect()</SDKLink> helper: throws a `404` error if the user is unauthorized.
    * Benefits: checks if the user is **both** authenticated **and** authorized. First, for the authentication check, if the user is not authenticated, the helper will redirect the user to the sign-in page if used on page, or will throw a `404` if used in a Route Handler. Then, for the authorization check, if the user is not authorized, the helper will throw a `404` error.
    * Limitations: doesn't offer control over the response, and can only be used on the server-side.
</If>

This guide will show you how to implement authorization checks in order to protect actions, content, or entire routes based on the user's **permissions**, but the same concepts can be applied to roles, features, and plans. When calling the `has()` helper, you would simply replace the `permission` parameter with the appropriate access control type, such as `role`, `feature`, or `plan`.

## Important considerations

* When doing authorization checks, it's recommended to use permission-based over role-based, and feature-based over plan-based authorization, as these approaches are more granular, flexible, and more secure.
  * Note: Using `has()` **on the server-side** to check permissions works only with **custom permissions**, as [system permissions](/docs/guides/organizations/roles-and-permissions#system-permissions) aren't included in the session token claims. To check system permissions, verify the user's role instead.
* Checking for a role or permission depends on the user having an <Tooltip><TooltipTrigger>active organization</TooltipTrigger><TooltipContent>A user can be a member of multiple organizations, but only one can be active at a time. The **active organization** determines which organization-specific data the user can access and which role and related permissions they have within the organization.</TooltipContent></Tooltip>. Without an active organization, the authorization checks will likely always evaluate to false by default.
* If you would like to perform role-based authorization checks **without** using Clerk's organizations feature, see <SDKLink href="/docs/guides/secure/basic-rbac" sdks={["nextjs"]}>the Role Based Access Control (RBAC) guide</SDKLink>.
* If you have both organizations and billing enabled, a permission check will only work if the feature part of the permission key (`org:<feature>:<permission>`) **is a feature included in the organization's active plan**. For example, say you want to check if an organization member has the custom permission `org:teams:manage`, where `teams` is the feature. Before performing the authorization check, you need to ensure that the user's organization is subscribed to a plan that has the `teams` feature. If not, the authorization check will always return `false`, *even if the user has the custom permission*.

<If sdk="nextjs">
  - Be cautious when doing authorization checks in layouts, as these don't re-render on navigation, meaning the user session won't be checked on every route change. [Read more in the Next.js docs](https://nextjs.org/docs/app/building-your-application/authentication#layouts-and-auth-checks).
</If>

### Use `has()` for authorization checks

The <SDKLink href="/docs/reference/backend/types/auth-object#has" sdks={["js-backend"]} code={true}>has()</SDKLink> helper returns `false` if the user does not have the correct access control. If they aren't authorized, you can choose how your app responds. It can be used to perform authorization checks in pages, route handlers, and Server Actions (Next.js only) to protect them from unauthorized access.

> \[!WARNING]
> Using `has()` **on the server-side** to check permissions works only with **custom permissions**, as [system permissions](/docs/guides/organizations/roles-and-permissions#system-permissions) aren't included in the session token claims. To check system permissions, verify the user's role instead.

<Tabs items={["Protect a page", "Protect a route handler", "Protect a Server Action"]}>
  <Tab>
    The following example demonstrates how to perform authorization checks in a page in order to protect the content from unauthorized access. It uses `has()` to check if the user has the `org:team_settings:manage` permission. If they aren't authorized, `null` is returned and the page isn't rendered.

    This example is written for Next.js App Router, but can be adapted to other frameworks by using <SDKLink href="/docs/reference/backend/types/auth-object#how-to-access-the-auth-object" sdks={["js-backend"]}>the appropriate method for accessing the `Auth` object</SDKLink>.

    ```tsx {{ filename: 'app/page.tsx' }}
    import { auth } from '@clerk/nextjs/server'

    export default async function Page() {
      // Use `auth()` to access the `has()` helper
      // For other frameworks, use the appropriate method for accessing the `Auth` object
      const { has } = await auth()

      // Check if the user is authorized
      const canManage = has({ permission: 'org:team_settings:manage' })

      // If has() returns false, the user does not have the correct permissions
      // You can choose how your app responds. This example returns null.
      if (!canManage) return null

      return <h1>Team Settings</h1>
    }
    ```
  </Tab>

  <Tab>
    The following example demonstrates how to perform authorization checks in a route handler in order to protect it from unauthorized access. It

    * uses the `isAuthenticated` returned from the <SDKLink href="/docs/reference/backend/types/auth-object" sdks={["js-backend"]} code={true}>Auth object</SDKLink> to check if the user is signed in. If the user is not **authenticated**, the Route Handler will return a `401` error.
    * uses `has()` to check if the user has the correct permission. If the user is not **authorized**, `has()` will return false, causing the Route Handler to return a `403` error.

    This example is written for Next.js App Router, but can be adapted to other frameworks by using the appropriate method for accessing the <SDKLink href="/docs/reference/backend/types/auth-object" sdks={["js-backend"]} code={true}>Auth object</SDKLink>.

    ```tsx {{ filename: 'app/api/get-teams/route.tsx' }}
    import { auth } from '@clerk/nextjs/server'

    export const GET = async () => {
      // Use `auth()` to access the `has()` helper and the `userId`
      // For other frameworks, use the appropriate method for accessing the `Auth` object
      const { isAuthenticated, userId, has } = await auth()

      // Check if the user is authenticated
      if (!isAuthenticated) {
        return Response.json({ error: 'User is not signed in' }, { status: 401 })
      }

      // Check if the user is authorized
      const canRead = has({ permission: 'org:team_settings:read' })

      // If has() returns false, the user does not have the correct permissions
      // You can choose how your app responds. This example returns a 403 error.
      if (!canRead)
        return Response.json({ error: 'User does not have the correct permissions' }, { status: 403 })

      // If the user is both authenticated and authorized, move forward with your logic
      return users.getTeams(userId)
    }
    ```
  </Tab>

  <Tab>
    The following example demonstrates how to perform authorization checks in a Server Action in order to protect the action from unauthorized access. It

    * uses the `isAuthenticated` returned from the <SDKLink href="/docs/reference/backend/types/auth-object" sdks={["js-backend"]} code={true}>Auth object</SDKLink> to check if the user is signed in. If the user is not **authenticated**, the Server Action will return a `401` error.
    * uses `has()` to check if the user has the correct permission. If the user is not **authorized**, `has()` will return false, causing the Server Action to return a `403` error.

    ```tsx {{ filename: 'app/components/ExampleServerComponent.tsx' }}
    import { auth } from '@clerk/nextjs/server'

    export default async function ExampleServerComponent() {
      async function myServerAction(formData: FormData) {
        'use server'
        // Use `auth()` to access the `has()` helper and the `userId`
        const { isAuthenticated, has, userId } = await auth()

        // Check if the user is authenticated
        if (!isAuthenticated) {
          return Response.json({ error: 'User is not signed in' }, { status: 401 })
        }

        // Check if the user is authorized
        const canManage = has({ permission: 'org:team_settings:manage' })

        // If has() returns false, the user does not have the correct permissions
        // You can choose how your app responds. This example returns a 403 error.
        if (!canManage)
          return Response.json({ error: 'User does not have the correct permissions' }, { status: 403 })

        // If the user is both authenticated and authorized, move forward with your logic
        return users.getTeams(userId)
      }

      return (
        <form action={myServerAction}>
          {/* Add UI for managing team settings */}
          <button type="submit">Submit</button>
        </form>
      )
    }
    ```
  </Tab>
</Tabs>

### Use `<Protect>` for authorization checks

The <SDKLink href="/docs/:sdk:/reference/components/control/protect" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue"]} code={true}>\<Protect></SDKLink> component prevents content from rendering if the user does not have the correct access control. If they aren't authorized, you can pass a fallback UI to the `fallback` prop. Under the hood, it uses the <SDKLink href="/docs/reference/backend/types/auth-object#has" sdks={["js-backend"]} code={true}>has()</SDKLink> helper so it can only check for custom permissions. It can be used both client-side and server-side (in Server Components).

The following example uses the `<Protect>` component to only render the content for users with the `org:team_settings:manage` permission. If they aren't authorized, `<Protect>` will render the fallback UI that's passed to the `fallback` prop.

```tsx {{ filename: 'app/page.tsx' }}
export default function Page() {
  return (
    <Protect
      permission="org:team_settings:manage"
      fallback={<p>You do not have the permissions to manage team settings.</p>}
    >
      <form>{/* Add UI for managing team settings */}</form>
    </Protect>
  )
}
```

<If sdk="nextjs">
  ### Use `auth.protect()` for authorization checks

  > \[!WARNING]
  > <SDKLink href="/docs/reference/nextjs/app-router/auth#auth-protect" sdks={["nextjs"]} code={true}>auth.protect()</SDKLink> is only available for App Router, and only works on the server-side.

  <Tabs items={["Protect a page", "Protect a route handler"]}>
    <Tab>
      The following example demonstrates how to use <SDKLink href="/docs/reference/nextjs/app-router/auth#auth-protect" sdks={["nextjs"]} code={true}>auth.protect()</SDKLink> to protect a page from unauthenticated and unauthorized access.

      * If the user is not authenticated, `auth.protect()` will redirect the user to the sign-in route.
      * If the user is authenticated but is not authorized (as in, does not have the `org:team_settings:read` permission), `auth.protect()` will throw a `404` error.
      * If the user is both authenticated and authorized, `auth.protect()` will return the user's `userId`.

      ```tsx {{ filename: 'app/dashboard/settings/page.tsx' }}
      import { auth } from '@clerk/nextjs/server'

      export default async function Page() {
        const { userId } = await auth.protect({ permission: 'org:team_settings:read' })

        return <p>{userId} is authorized to access this page.</p>
      }
      ```
    </Tab>

    <Tab>
      The following example demonstrates how to use <SDKLink href="/docs/reference/nextjs/app-router/auth#auth-protect" sdks={["nextjs"]} code={true}>auth.protect()</SDKLink> to protect a route handler from unauthenticated and unauthorized access.

      * If the user is not authenticated **nor** authorized (as in, does not have the `org:team_settings:manage` permission), `auth.protect()` will throw a `404` error.
      * If the user is both authenticated and authorized, `auth.protect()` will return the user's `userId`.

      ```tsx {{ filename: 'app/api/create-team/route.tsx' }}
      import { auth } from '@clerk/nextjs/server'

      export const GET = async () => {
        const { userId } = await auth.protect({
          permission: 'org:team_settings:manage',
        })

        return Response.json({ userId })
      }
      ```
    </Tab>
  </Tabs>
</If>

## Authorization checks in JavaScript

If you are not using React-based frameworks, you can use the <SDKLink href="/docs/reference/javascript/overview" sdks={["js-frontend"]}>Clerk JavaScript SDK</SDKLink> to perform authorization checks. The following example demonstrates how to use the <SDKLink href="/docs/reference/javascript/session#check-authorization" sdks={["js-frontend"]} code={true}>checkAuthorization()</SDKLink> method to check if a user is authorized.

<Tabs items={["JavaScript"]}>
  <Tab>
    ```tsx {{ filename: 'main.js' }}
    import { Clerk } from '@clerk/clerk-js'

    const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY

    const clerk = new Clerk(clerkPubKey)
    await clerk.load()

    // Check if the user is authenticated
    if (clerk.isSignedIn) {
      // Check if the user is authorized
      const canManageSettings = clerk.session.checkAuthorization({
        permission: 'org:team_settings:manage',
      })
    }
    ```
  </Tab>
</Tabs>

## Add custom types

In order to enhance typesafety in your project, you can define a global `ClerkAuthorization` interface, which defines the acceptable values for custom access control types.

> \[!NOTE]
> By default, roles and permission types, such as `OrganizationCustomRoleKey` and `OrganizationCustomPermissionKey`, are assigned `string`. However, if a `ClerkAuthorization` type is defined, it will be utilized instead.

The following example demonstrates how to define a global `ClerkAuthorization` interface with the default roles that Clerk provides.

```tsx {{ filename: 'types/globals.d.ts' }}
export {}

declare global {
  interface ClerkAuthorization {
    permission: ''
    role: 'org:admin' | 'org:member'
  }
}
```

Because Clerk supports custom access control types, you can modify `ClerkAuthorization` to align with the custom access control types configured in your Clerk application. See the following example, where the default Clerk roles `org:admin` and `org:member` are replaced with custom roles `org:super_admin`, `org:teacher`, and `org:student`, and custom permissions are also added.

```tsx {{ filename: 'types/globals.d.ts' }}
export {}

declare global {
  interface ClerkAuthorization {
    permission: 'org:quiz:create' | 'org:quiz:grade' | 'org:quiz:read' | 'org:quiz:fill'
    role: 'org:super_admin' | 'org:teacher' | 'org:student'
  }
}
```

---

---
title: clerkMiddleware() | Next.js
description: The clerkMiddleware() function allows you to protect your Next.js
  application using Middleware.
sdk: nextjs
sdkScoped: "true"
canonical: /docs/reference/nextjs/clerk-middleware
lastUpdated: 2025-10-28T19:57:28.000Z
availableSdks: nextjs
notAvailableSdks: react,js-frontend,chrome-extension,expo,android,ios,expressjs,fastify,react-router,remix,tanstack-react-start,go,astro,nuxt,vue,ruby,js-backend
activeSdk: nextjs
sourceFile: /docs/reference/nextjs/clerk-middleware.mdx
---

The `clerkMiddleware()` helper integrates Clerk authentication into your Next.js application through Middleware. `clerkMiddleware()` is compatible with both the App and Pages routers.

## Configure `clerkMiddleware()`

<If sdk="nextjs">
  > \[!IMPORTANT]
  >
  > If you're using Next.js ≤15, name your file `middleware.ts` instead of `proxy.ts`. The code itself remains the same; only the filename changes.
</If>

Create a `proxy.ts` file at the root of your project, or in your `src/` directory if you have one.

> \[!NOTE]
> For more information about Middleware in Next.js, see the [Next.js documentation](https://nextjs.org/docs/app/api-reference/file-conventions/proxy).

```tsx {{ filename: 'proxy.ts' }}
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware()

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

By default, `clerkMiddleware` will not protect any routes. All routes are public and you must opt-in to protection for routes.

## `createRouteMatcher()`

`createRouteMatcher()` is a Clerk helper function that allows you to protect multiple routes. `createRouteMatcher()` accepts an array of routes and checks if the route the user is trying to visit matches one of the routes passed to it. The paths provided to this helper can be in the same format as the paths provided to the Next Middleware matcher.

The `createRouteMatcher()` helper returns a function that, if called with the `req` object from the Middleware, will return `true` if the user is trying to access a route that matches one of the routes passed to `createRouteMatcher()`.

In the following example, `createRouteMatcher()` sets all `/dashboard` and `/forum` routes as protected routes.

```tsx
const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])
```

## Protect routes

You can protect routes using either or both of the following:

* [Authentication-based protection](#protect-routes-based-on-authentication-status): Verify if the user is signed in.
* [Authorization-based protection](#protect-routes-based-on-authorization-status): Verify if the user has the required organization roles or custom permissions.

> \[!TIP]
> If you have a `<Link>` tag on a public page that points to a protected page that returns a `400`-level error, like a `401`, the data prefetch will fail because it will be redirected to the sign-in page and throw a confusing error in the console. To prevent this behavior, disable prefetching by adding `prefetch={false}` to the `<Link>` component.

### Protect routes based on authentication status

You can protect routes based on a user's authentication status by checking if the user is signed in.

There are two methods that you can use:

* Use [`auth.protect()`](/docs/reference/nextjs/app-router/auth#auth-protect) if you want to redirect unauthenticated users to the sign-in route automatically.
* Use [`auth().isAuthenticated`](/docs/reference/nextjs/app-router/auth#protect-pages-and-routes) if you want more control over what your app does based on user authentication status.

<CodeBlockTabs options={["auth.protect()", "auth().isAuthenticated()"]}>
  ```tsx {{ filename: 'proxy.ts' }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

  const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

  export default clerkMiddleware(async (auth, req) => {
    if (isProtectedRoute(req)) await auth.protect()
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  ```tsx {{ filename: 'app/proxy.ts' }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

  const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

  export default clerkMiddleware(async (auth, req) => {
    const { isAuthenticated, redirectToSignIn } = await auth()

    if (!isAuthenticated && isProtectedRoute(req)) {
      // Add custom logic to run before redirecting

      return redirectToSignIn()
    }
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```
</CodeBlockTabs>

### Protect routes based on authorization status

You can protect routes based on a user's authorization status by checking if the user has the required roles or permissions.

There are two methods that you can use:

* Use [`auth.protect()`](/docs/reference/nextjs/app-router/auth#auth-protect) if you want Clerk to return a `404` if the user does not have the role or permission.
* Use <SDKLink href="/docs/reference/backend/types/auth-object#has" sdks={["js-backend"]} code={true}>auth().has()</SDKLink> if you want more control over what your app does based on the authorization status.

<Tabs items={["auth.protect()", "auth().has()"]}>
  <Tab>
    ```tsx {{ filename: 'proxy.ts' }}
    import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

    const isProtectedRoute = createRouteMatcher(['/admin(.*)'])

    export default clerkMiddleware(async (auth, req) => {
      // Restrict admin routes to users with specific permissions
      if (isProtectedRoute(req)) {
        await auth.protect((has) => {
          return has({ permission: 'org:admin:example1' }) || has({ permission: 'org:admin:example2' })
        })
      }
    })

    export const config = {
      matcher: [
        // Skip Next.js internals and all static files, unless found in search params
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // Always run for API routes
        '/(api|trpc)(.*)',
      ],
    }
    ```
  </Tab>

  <Tab>
    > \[!WARNING]
    > Using `has()` **on the server-side** to check permissions works only with **custom permissions**, as [system permissions](/docs/guides/organizations/roles-and-permissions#system-permissions) aren't included in the session token claims. To check system permissions, verify the user's role instead.

    ```tsx {{ filename: 'proxy.ts' }}
    import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

    const isProtectedRoute = createRouteMatcher(['/admin(.*)'])

    export default clerkMiddleware(async (auth, req) => {
      const { has, redirectToSignIn } = await auth()
      // Restrict admin routes to users with specific permissions
      if (
        (isProtectedRoute(req) && !has({ permission: 'org:admin:example1' })) ||
        !has({ permission: 'org:admin:example2' })
      ) {
        // Add logic to run if the user does not have the required permissions

        return redirectToSignIn()
      }
    })

    export const config = {
      matcher: [
        // Skip Next.js internals and all static files, unless found in search params
        '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
        // Always run for API routes
        '/(api|trpc)(.*)',
      ],
    }
    ```
  </Tab>
</Tabs>

## Protect multiple groups of routes

You can use more than one `createRouteMatcher()` in your application if you have two or more groups of routes.

The following example uses the <SDKLink href="/docs/reference/backend/types/auth-object#has" sdks={["js-backend"]} code={true}>has()</SDKLink> method from the `auth()` helper.

> \[!TIP]
> If you have a `<Link>` tag on a public page that points to a protected page that returns a `400`-level error, like a `401`, the data prefetch will fail because it will be redirected to the sign-in page and throw a confusing error in the console. To prevent this behavior, disable prefetching by adding `prefetch={false}` to the `<Link>` component.

```tsx {{ filename: 'proxy.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isTenantRoute = createRouteMatcher(['/organization-selector(.*)', '/orgid/(.*)'])

const isTenantAdminRoute = createRouteMatcher(['/orgId/(.*)/memberships', '/orgId/(.*)/domain'])

export default clerkMiddleware(async (auth, req) => {
  // Restrict admin routes to users with specific permissions
  if (isTenantAdminRoute(req)) {
    await auth.protect((has) => {
      return has({ permission: 'org:admin:example1' }) || has({ permission: 'org:admin:example2' })
    })
  }
  // Restrict organization routes to signed in users
  if (isTenantRoute(req)) await auth.protect()
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

## Protect all routes

To protect all routes in your application and define specific routes as public, you can use any of the above methods and simply invert the `if` condition.

> \[!TIP]
> If you have a `<Link>` tag on a public page that points to a protected page that returns a `400`-level error, like a `401`, the data prefetch will fail because it will be redirected to the sign-in page and throw a confusing error in the console. To prevent this behavior, disable prefetching by adding `prefetch={false}` to the `<Link>` component.

```tsx {{ filename: 'proxy.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isPublicRoute = createRouteMatcher(['/sign-in(.*)', '/sign-up(.*)'])

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect()
  }
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

## Protect routes based on token types

You can protect routes based on token types by checking if the request includes the required token (e.g. OAuth token, API key, machine token or session token). This ensures that only requests with the appropriate token type can access the route.

The following example uses the [`protect()`](/docs/reference/nextjs/app-router/auth#auth-protect) method from the `auth()` helper. Requests without the required token will return an appropriate error:

* A `404` error for unauthenticated requests with a session token type.
* A `401` error for unauthenticated requests with machine token types.

```tsx {{ filename: 'proxy.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

// Create route matchers to identify which token type each route should require
const isOAuthAccessible = createRouteMatcher(['/oauth(.*)'])
const isApiKeyAccessible = createRouteMatcher(['/api(.*)'])
const isMachineTokenAccessible = createRouteMatcher(['/m2m(.*)'])
const isUserAccessible = createRouteMatcher(['/user(.*)'])
const isAccessibleToAnyValidToken = createRouteMatcher(['/any(.*)'])

export default clerkMiddleware(async (auth, req) => {
  // Check if the request matches each route and enforce the corresponding token type
  if (isOAuthAccessible(req)) await auth.protect({ token: 'oauth_token' })
  if (isApiKeyAccessible(req)) await auth.protect({ token: 'api_key' })
  if (isMachineTokenAccessible(req)) await auth.protect({ token: 'm2m_token' })
  if (isUserAccessible(req)) await auth.protect({ token: 'session_token' })

  if (isAccessibleToAnyValidToken(req)) await auth.protect({ token: 'any' })
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

## Debug your Middleware

If you are having issues getting your Middleware dialed in, or are trying to narrow down auth-related issues, you can use the debugging feature in `clerkMiddleware()`. Add `{ debug: true }` to `clerkMiddleware()` and you will get debug logs in your terminal.

```tsx {{ filename: 'proxy.ts', mark: [[4, 7]] }}
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  { debug: true },
)

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

If you would like to set up debugging for your development environment only, you can use the `process.env.NODE_ENV` variable to conditionally enable debugging. For example, `{ debug: process.env.NODE_ENV === 'development' }`.

## Combine Middleware

You can combine other Middleware with Clerk's Middleware by returning the second Middleware from `clerkMiddleware()`.

```js {{ filename: 'proxy.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
import createMiddleware from 'next-intl/middleware'

import { AppConfig } from './utils/AppConfig'

const intlMiddleware = createMiddleware({
  locales: AppConfig.locales,
  localePrefix: AppConfig.localePrefix,
  defaultLocale: AppConfig.defaultLocale,
})

const isProtectedRoute = createRouteMatcher(['dashboard/(.*)'])

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) await auth.protect()

  return intlMiddleware(req)
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

## `clerkMiddleware()` options

The `clerkMiddleware()` function accepts an optional object. The following options are available:

<Properties>
  * `audience?`
  * `string | string[]`

  A string or list of [audiences](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3). If passed, it is checked against the `aud` claim in the token.

  ***

  * `authorizedParties?`
  * `string[]`

  An allowlist of origins to verify against, to protect your application from the subdomain cookie leaking attack. For example: `['http://localhost:3000', 'https://example.com']`

  ***

  * `clockSkewInMs?`
  * `number`

  Specifies the allowed time difference (in milliseconds) between the Clerk server (which generates the token) and the clock of the user's application server when validating a token. Defaults to 5000 ms (5 seconds).

  ***

  * `domain?`
  * `string`

  The domain used for satellites to inform Clerk where this application is deployed.

  ***

  * `isSatellite?`
  * `boolean`

  When using Clerk's satellite feature, this should be set to `true` for secondary domains.

  ***

  * `jwtKey`
  * `string`

  Used to verify the session token in a networkless manner. Supply the **JWKS Public Key** from the [**API keys**](https://dashboard.clerk.com/~/api-keys) page in the Clerk Dashboard. **It's recommended to use [the environment variable](/docs/guides/development/clerk-environment-variables) instead.** For more information, refer to [Manual JWT verification](/docs/guides/sessions/manual-jwt-verification).

  ***

  * `organizationSyncOptions?`
  * <code>[OrganizationSyncOptions](#organization-sync-options) | undefined</code>

  Used to activate a specific [organization](/docs/guides/organizations/overview) or [personal account](/docs/guides/dashboard/overview) based on URL path parameters. If there's a mismatch between the <Tooltip><TooltipTrigger>active organization</TooltipTrigger><TooltipContent>A user can be a member of multiple organizations, but only one can be active at a time. The **active organization** determines which organization-specific data the user can access and which role and related permissions they have within the organization.</TooltipContent></Tooltip> in the session (e.g., as reported by [`auth()`](/docs/reference/nextjs/app-router/auth)) and the organization indicated by the URL, the middleware will attempt to activate the organization specified in the URL.

  ***

  * `proxyUrl?`
  * `string`

  Specify the URL of the proxy, if using a proxy.

  ***

  * `signInUrl`
  * `string`

  The full URL or path to your sign-in page. Needs to point to your primary application on the client-side. **Required for a satellite application in a development instance.** It's recommended to use [the environment variable](/docs/guides/development/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ***

  * `signUpUrl`
  * `string`

  The full URL or path to your sign-up page. Needs to point to your primary application on the client-side. **Required for a satellite application in a development instance.** It's recommended to use [the environment variable](/docs/guides/development/clerk-environment-variables#sign-in-and-sign-up-redirects) instead.

  ***

  * `publishableKey`
  * `string`

  The Clerk Publishable Key for your instance. This can be found on the [**API keys**](https://dashboard.clerk.com/~/api-keys) page in the Clerk Dashboard.

  ***

  * `secretKey?`
  * `string`

  The Clerk Secret Key for your instance. This can be found on the [**API keys**](https://dashboard.clerk.com/~/api-keys) page in the Clerk Dashboard. The `CLERK_ENCRYPTION_KEY` environment variable must be set when providing `secretKey` as an option, refer to [Dynamic keys](#dynamic-keys).
</Properties>

It's also possible to dynamically set options based on the incoming request:

```ts {{ filename: 'proxy.ts' }}
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  (req) => ({
    // Provide `domain` based on the request host
    domain: req.nextUrl.host,
  }),
)
```

### Dynamic keys

> \[!NOTE]
> Dynamic keys are not accessible on the client-side.

The following options, known as "Dynamic Keys," are shared to the Next.js application server through `clerkMiddleware`, enabling access by server-side helpers like [`auth()`](/docs/reference/nextjs/app-router/auth):

* `signUpUrl`
* `signInUrl`
* `secretKey`
* `publishableKey`

Dynamic keys are encrypted and shared during request time using a [AES encryption algorithm](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard). When providing a `secretKey`, the `CLERK_ENCRYPTION_KEY` environment variable is mandatory and used as the encryption key. If no `secretKey` is provided to `clerkMiddleware`, the encryption key defaults to `CLERK_SECRET_KEY`.

When providing `CLERK_ENCRYPTION_KEY`, it is recommended to use a 32-byte (256-bit), pseudorandom value. You can use `openssl` to generate a key:

```sh {{ filename: 'terminal' }}
openssl rand --hex 32
```

For multi-tenant applications, you can dynamically define Clerk keys depending on the incoming request. Here's an example:

```ts {{ filename: 'proxy.ts' }}
import { clerkMiddleware } from '@clerk/nextjs/server'

// You would typically fetch these keys from a external store or environment variables.
const tenantKeys = {
  tenant1: { publishableKey: 'pk_tenant1...', secretKey: 'sk_tenant1...' },
  tenant2: { publishableKey: 'pk_tenant2...', secretKey: 'sk_tenant2...' },
}

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  (req) => {
    // Resolve tenant based on the request
    const tenant = getTenant(req)
    return tenantKeys[tenant]
  },
)
```

### `OrganizationSyncOptions`

The `organizationSyncOptions` property on the [`clerkMiddleware()`](#clerk-middleware-options) options
object has the type `OrganizationSyncOptions`, which has the following properties:

<Properties>
  * `organizationPatterns`
  * <code>[Pattern](#pattern)\[]</code>

  Specifies URL patterns that are organization-specific, containing an organization ID or slug as a path parameter. If a request
  matches this path, the organization identifier will be used to set that org as active.

  If the route also matches the `personalAccountPatterns` prop, this prop takes precedence.

  Patterns must have a path parameter named either `:id` (to match a Clerk organization ID) or `:slug` (to match a Clerk organization slug).

  > \[!WARNING]
  > If the organization can't be activated—either because it doesn't exist or the user lacks access—the previously <Tooltip><TooltipTrigger>active organization</TooltipTrigger><TooltipContent>A user can be a member of multiple organizations, but only one can be active at a time. The **active organization** determines which organization-specific data the user can access and which role and related permissions they have within the organization.</TooltipContent></Tooltip> will remain unchanged. Components must detect this case and provide an appropriate error and/or resolution pathway, such as calling `notFound()` or displaying an <SDKLink href="/docs/:sdk:/reference/components/organization/organization-switcher" sdks={["astro","chrome-extension","expo","nextjs","nuxt","react","react-router","remix","tanstack-react-start","vue","js-frontend"]} code={true}>\<OrganizationSwitcher /></SDKLink>.

  Common examples:

  * `["/orgs/:slug", "/orgs/:slug/(.*)"]`
  * `["/orgs/:id", "/orgs/:id/(.*)"]`
  * `["/app/:any/orgs/:slug", "/app/:any/orgs/:slug/(.*)"]`

  ***

  * `personalAccountPatterns`
  * <code>[Pattern](#pattern)\[]</code>

  URL patterns for resources that exist within the context of a user's [personal account](/docs/guides/organizations/overview#allow-personal-accounts).

  If the route also matches the `organizationPattern` prop, the `organizationPattern` prop takes precedence.

  Common examples:

  * `["/me", "/me/(.*)"]`
  * `["/user/:any", "/user/:any/(.*)"]`
</Properties>

### Pattern

A `Pattern` is a `string` that represents the structure of a URL path. In addition to any valid URL, it may include:

* Named path parameters prefixed with a colon (e.g., `:id`, `:slug`, `:any`).
* Wildcard token, `(.*)`, which matches the remainder of the path.

#### Examples

* `/orgs/:slug`

| URL | Matches | `:slug` value |
| - | - | - |
| `/orgs/acmecorp` | ✅ | `acmecorp` |
| `/orgs` | ❌ | n/a |
| `/orgs/acmecorp/settings` | ❌ | n/a |

* `/app/:any/orgs/:id`

| URL | Matches | `:id` value |
| - | - | - |
| `/app/petstore/orgs/org_123` | ✅ | `org_123` |
| `/app/dogstore/v2/orgs/org_123` | ❌ | n/a |

* `/personal-account/(.*)`

| URL | Matches |
| - | - |
| `/personal-account/settings` | ✅ |
| `/personal-account` | ❌ |
